# ForkJoinPool

ForkJoinPool 是 Java 并发包中的高性能线程池，特别适合 **CPU 密集型** 和 **递归分治型任务**。它的核心思想是：**工作窃取（Work Stealing）+ 分治并行执行（Fork/Join）**。



下面我们从整体架构、线程模型、任务调度、工作窃取、源码结构等角度深入剖析 ForkJoinPool 的原理。

## **一、ForkJoinPool 简介**

- 类路径：java.util.concurrent.ForkJoinPool
- 核心目的：提升多核 CPU 的使用率，避免线程上下文切换开销。
- 场景：适用于 CPU 密集型计算，如递归计算、大数据并行处理、图像渲染等。



## **二、核心特点**

| **特性**                  | **描述**                                                 |
| ------------------------- | -------------------------------------------------------- |
| 分治模型（Fork/Join）     | 拆分任务（fork）并行处理，最后汇总结果（join）           |
| 工作窃取（Work Stealing） | 空闲线程会从其他线程的任务队列中“偷”任务，提升线程利用率 |
| 每线程独立队列            | 每个 Worker 线程有自己专属双端队列，减少锁竞争           |
| 支持异步执行              | CompletableFuture 默认使用 ForkJoinPool.commonPool()     |

## **三、基本执行流程**

以 ForkJoinTask.invoke() 为例：

流程简述如下：

1. 创建线程池（或使用默认 commonPool）。

2. 提交 ForkJoinTask 任务。

3. 当前线程/工作线程执行任务：

   - 如果任务足够小，直接计算。
   - 如果任务较大，拆分成子任务（fork()），放入线程自己的队列。
   
4. 子任务完成后，合并结果（join()）。

5. 空闲线程会窃取其他线程队列中的任务执行。



## **四、线程与任务结构**

### 1. 每个工作线程（ForkJoinWorkerThread)

- 拥有一个 **双端队列（Deque）**，用来存放自己的任务。
- 自己从队尾（**LIFO**）获取任务，保证局部性。
- 窃取线程从队首（**FIFO**）偷任务，避免竞争。



### 2. 任务结构（ForkJoinTask)

- 任务可以继续拆分成子任务（fork()），
- 等待子任务完成再 join() 合并。

## **五、工作窃取原理（Work Stealing）**

核心目标：**让线程始终有活干，提升 CPU 利用率**

- 每个线程处理自己的任务队列，正常从队尾取。

- 当队列空了：

  - 它从别的线程的队列**头部**偷一个任务。

- 线程之间**不共享任务队列**，只在窃取时访问其他线程队列（使用 CAS 保证安全）。

### **为什么队尾取，队首偷？**

- 本地队尾是 LIFO，最近提交的任务可能数据还在 CPU cache 中。
- 被偷的队首任务更早提交，适合并发执行。
- 分别取头和尾，减少冲突。

## **六、线程池管理结构**

### **核心字段**

```
ForkJoinPool
 ├── workers[]：所有工作线程
 ├── ctl：控制状态（CAS 原子更新）
 ├── runState：池状态（运行、关闭等）
 ├── workQueue[]：工作队列数组
```

- 线程池通过 ctl 和 workQueue 管理任务和线程状态。
- ctl 是个 64 位 long，记录工作线程数量、空闲线程等状态。

## **七、任务执行流程图**

```
                    提交任务
                       ↓
               +----------------+
               | ForkJoinPool   |
               +----------------+
                       ↓
            将任务放入当前线程队列尾
                       ↓
               当前线程执行任务
                       ↓
          ┌────────────┴────────────┐
          ↓                         ↓
     任务足够小？               拆分为子任务
          ↓                         ↓
      直接执行               子任务 fork() 入队
                                  ↓
                      等子任务完成后 join()
                       ↓
               合并结果并返回
```



| **特性**     | **ForkJoinPool**       | **ThreadPoolExecutor**                 |
| ------------ | ---------------------- | -------------------------------------- |
| 任务队列     | 每线程独立队列（无锁） | 全局阻塞队列（如 LinkedBlockingQueue） |
| 工作窃取     | ✅                      | ❌                                      |
| 适用场景     | 递归分治、CPU 密集型   | IO 密集、常规并发任务处理              |
| 执行策略     | fork-join 模型         | worker-queue 模型                      |
| 默认线程数量 | CPU 核心数             | 默认需手动                             |

| **模块** | **描述**                                      |
| -------- | --------------------------------------------- |
| 线程模型 | 每个线程一个队列，减少锁竞争                  |
| 工作窃取 | 空闲线程主动从别人队首偷任务，提升 CPU 利用率 |
| 执行机制 | fork 分任务，join 合并结果                    |
| 调度策略 | 当前线程优先执行自己的任务，阻塞时尝试偷任务  |
| 适用场景 | 计算密集型、递归任务、大数据拆分并行          |